{
  "language": "Solidity",
  "sources": {
    "contracts/Cretter.sol": {
      "content": "pragma solidity ^0.6.8;\n\nlibrary CheckOverflows {\n    function add(uint256 n1, uint256 n2) internal pure returns(uint256 n3) {\n        n3 = n1 + n2;\n        require(n3 >= n1);\n        return n3;\n    }\n\n    function sub(uint256 n1, uint256 n2) internal pure returns(uint256) {\n        require(n2 <= n1);\n        return n1 - n2;\n    }\n\n    function mul(uint256 n1, uint256 n2) internal pure returns(uint256 n3) {\n        if (n1 == 0 || n2 == 0) {\n            return 0;\n        }\n\n        n3 = n1 * n2;\n        require(n3 / n1 == n2);\n        return n3;\n    }\n\n    function div(uint256 n1, uint256 n2) internal pure returns(uint256) {\n        return n1 / n2;\n    }\n}\n\n\n/*\n * This is 1st version of Cretter 2.0\n * $10 (0.04eth) to make a StatementBank\n * $1 (0.004eth) to be a Questioner (Win: gets double of stake or lose it)\n * Strict order of actions: Statement -> Questioner -> Answer -> Votes -> Finalize\n */\n\n/*\n * Time restriction: \n *   - 4 days question voting\n *   - 31 days statement being live \n *   - There is only a window of 22 days which you can ask a question\n */\n\n// This is the Stater's bank If he's with the truth\n// The amount of money will keep growing until maturity\n// Scheduler at 30 days kills the contract | to save space on network\n// and gas refund\ncontract StatementBank {\n    using CheckOverflows for uint256;\n\n    address payable public stater; // owner\n\n    uint256 public firstQuestioner;\n    uint256 public lastQuestioner;\n    uint256 public createdAt;\n    uint256 public questionDeadline;\n    uint256 public statementTimeLock;\n\n    // returns the amount the statementBank has at all times\n    function statementBankBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    // potential util for generating a random number to get\n    // voter who gets reward\n    // set to public for testing [TODO: must set to private]\n    // arg: _numberOfVoters number of voters\n    // result: starts at zero | \n    function random(uint256 _numberOfVoters) public view returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty))) % _numberOfVoters;\n    }\n\n    // (1): stater posts a statement\n    constructor() public payable {\n        require(msg.value == 0.04 ether);\n        stater = msg.sender;\n        firstQuestioner = 0;\n        lastQuestioner = 0;\n        // natural unit of time on EVM is seconds\n        createdAt = now;\n        // 18 days to ask a questions\n        questionDeadline = now + 5 minutes;\n        statementTimeLock = now + 10 minutes;\n    }\n\n    // We're using a FIFO data structure, that represents the order of\n    // questions, first ones get settled first\n    // firstQuestioner and lastQuestioner serve as the index for both:\n    // questioners order and votes on each on those question\n    // 1st arg: _questionIndex\n    // result: questioner's address\n    mapping (uint256 => address payable) public questioners;\n\n\n    // (2): questioner asks a question\n    // only question staker should be able to run this function\n    // [No restriction] on when a question stake can be issued\n    // [todo: Maybe deactivate when contract less than $2]\n    // The more money in the contract (and less true), the more likely a questionerStake\n    function questionerStake() payable public {\n        // should be called before deadline\n        require(questionDeadline > now);\n        require(msg.value == 0.004 ether);\n        require(stater != msg.sender);\n        lastQuestioner = lastQuestioner.add(1);\n        questioners[lastQuestioner] = msg.sender;\n    }\n    \n    // question got an answer from stater\n    // This is to safeguard the must follow cretter: statement -> question -> answer -> votes\n    // 1st arg: _questionIndex\n    // 2nd arg: whether the question got answer (existence is yes/1)\n    mapping (uint256 => uint256) public questionGotAnswer;\n    \n    // (3): stater answers to question\n    // The only way for the stater to signal that he/she actually answered\n    // the question is by making a transaction\n    function staterProvidesAnswer(uint256 _questionIndex) public {\n        require (msg.sender == stater);\n\n        // stater can't signal he already answered a question\n        // when a question hasn't been asked yet | mainly checking for existence\n        require(lastQuestioner > _questionIndex);\n        \n        questionGotAnswer[_questionIndex] = 1;\n        \n        // TODO: disable stater being able to call this function again.\n        // Stater can't update or edit, an already supplied answer\n        // 99 coz bearish on answers by default (100 or above, stater is winning)\n        staterAgainstQuestionIndex[_questionIndex] = 99;\n    }\n\n    // 1st arg: _questionIndex\n    // 2nd arg: _truthIndex\n    // the truth index threshold is 100 (100 or above stater wins - starts at 99)\n    // lower: stater is losing argument over the question at _questionIndex\n    // higher: stater is winning argument ...\n    mapping (uint256 => uint256) public staterAgainstQuestionIndex;\n\n    // 1st arg: _questionIndex\n    // 2nd arg: voterAddress\n    // 3rd: 1 > signifies [voted] // existence means yes/1\n    mapping (uint256 => mapping (address => uint256)) public hasAlreadyVoted;\n    \n    // mapping to mainly reward the lucky voter who got it right\n    mapping (uint256 => address payable[]) votedForStater;\n    mapping (uint256 => address payable[]) votedForQuestioner;\n    \n    // (4): voting\n    // Vote answer on question, binary:\n    // * satisfying: stater wins / Vote\n    // * unsatisfying: questioner wins / Vote\n    // 1st arg: _questionIndex \n    // 2nd arg: vote: 1 stater favor (agree answer), 2 questioner favor (disagree answer)\n    function vote(uint256 _questionIndex, uint256 _vote) public {\n        \n        require(questionGotAnswer[_questionIndex] == 1);\n        \n        // stater or questioner can't vote\n        require(msg.sender != stater);\n        // This has a 0.2% gas limit addition so add it (not big)\n        require(msg.sender != questioners[_questionIndex]);\n        \n        // if already voted _questionIndex, can't vote again\n        require(hasAlreadyVoted[_questionIndex][msg.sender] != 1);\n        \n        // 1 stater favor (agree answer)\n        if (_vote == 1) {\n            staterAgainstQuestionIndex[_questionIndex] = staterAgainstQuestionIndex[_questionIndex].add(1);\n            votedForStater[_questionIndex].push(msg.sender);\n            \n        // 2 questioner favor (disagree answer)\n        } else if (_vote == 2) {\n            staterAgainstQuestionIndex[_questionIndex] = staterAgainstQuestionIndex[_questionIndex].sub(1);\n            votedForQuestioner[_questionIndex].push(msg.sender);\n        }\n        \n        // record voter\n        hasAlreadyVoted[_questionIndex][msg.sender] = 1;\n    }\n    \n    \n    // [Only] Scheduler can call this\n    // Function [dequeue] the oldest question \n    // * To save on transfer fees and give an addictive spin:\n    // * choose a random ranker who got it right and pay him $0.5\n    // [originally 10% of the questioner's stake was the spec]\n    function finalizeQuestionerChallenge () public returns (address removedQuestionerAddr) {\n        require(lastQuestioner >= firstQuestioner);\n        \n        // Test still\n        // require(msg.sender == address(0xa639cc7A169E848B280acd1B493a7D5Af44507a4)); \n\n        // If stater didn't answer, questioner wins automatically\n        // 0 is the default (represent not having an answer)\n\n        // If SAQI is 99, voters didn't move the needle, they don't get paid\n        if (questionGotAnswer[firstQuestioner] == 0 || staterAgainstQuestionIndex[firstQuestioner] == 99) {\n            questioners[firstQuestioner].transfer(0.008 ether);\n        } else if (staterAgainstQuestionIndex[firstQuestioner] < 100) {\n            // questioner wins, he gets 2x his staked money\n            questioners[firstQuestioner].transfer(0.008 ether);\n\n            // reward a random ranker who betted on questioner\n\n            uint256 questLen = votedForQuestioner[firstQuestioner].length;\n\n            uint256 questVoteIndex = random(questLen);\n\n            // Important votedForStater && votedForQuestioner started with index 0\n            // Must decrease by 1 for proper indexing\n            address payable questionerRankingWinner = votedForQuestioner[firstQuestioner][questVoteIndex];\n            \n            // Variable reward: the earlier you voted the more you deserve a full reward\n            \n            // uint256 questVoterReward = 2000000000000000 * (1 - (questVoteIndex / questLen)); // in wei\n            uint256 questVoterReward = uint256(2000000000000000).sub( uint256(2000000000000000).mul(questVoteIndex).div(questLen) );\n            \n            questionerRankingWinner.transfer(questVoterReward);\n            \n        } else if (staterAgainstQuestionIndex[firstQuestioner] >= 100) {\n            // stater is winning (a tie, he's still winning) coz\n            // the goal of questioner is to kill the statement\n            // > nothing to do here money stays in the contract\n            // > reward a random ranker who betted on stater\n            \n            uint256 stateLen = votedForStater[firstQuestioner].length;\n            uint256 staterVoteIndex = random(stateLen);\n            address payable staterRankingWinner = votedForStater[firstQuestioner][staterVoteIndex];\n\n            \n            uint256 stateVoterReward = uint256(2000000000000000).sub( uint256(2000000000000000).mul(staterVoteIndex).div(stateLen) );\n            staterRankingWinner.transfer(stateVoterReward);\n        }\n        \n        removedQuestionerAddr = questioners[firstQuestioner];\n        delete questioners[firstQuestioner];\n\n        firstQuestioner = firstQuestioner.add(1);\n    }\n    \n    // Until a stater can retrieve money from the statementBankBalance\n    // [This to be implemented later]\n    \n    // Only Scheduler can call this\n    function staterReceivesLoot() public {\n        // require(msg.sender == address(0xa639cc7A169E848B280acd1B493a7D5Af44507a4));\n        // should be called after deadline\n\n        require(now > statementTimeLock);\n\n        \n        // We need a bunch of checks here \n        // All rounds of questions challenges must be done\n        // All question challenges finalized\n        require(lastQuestioner == firstQuestioner);\n        \n        // TODO: implement time waiting requirement\n        // The only strict restriction is that enough time like 2 weeks should go on\n        \n        // Fund future development of cretter\n        uint256 fundCretterFuture = 4000000000000000; // 0.004 ether \n        address payable cretterFundAddr = 0x87aD567CE024832E60529e11e70cb3788611F1E8;\n        \n        cretterFundAddr.transfer(fundCretterFuture);\n        stater.transfer(statementBankBalance() - fundCretterFuture);      \n    }\n    \n    // Funders can donate and keep statement live\n    // for more interaction even after stater withdrawal\n    // Reward always goes to stater though (if not drained by questioners)\n    function donateToStatementBank() public payable {\n        \n    }\n}"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}