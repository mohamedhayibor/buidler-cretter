{
  "language": "Solidity",
  "sources": {
    "contracts/Cretter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.8;\n\n// From https://github.com/OpenZeppelin/openzeppelin-contracts\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n/*\n * This is 1st version of Cretter 2.0\n * $10 (0.04eth) to make a StatementBank\n * $1 (0.004eth) to be a Questioner (Win: gets double of stake or lose it)\n * Strict order of actions: Statement -> Questioner -> Answer -> Votes -> Finalize\n */\n\n/*\n * Time restriction: \n *   - 4 days question voting\n *   - 31 days statement being live \n *   - There is only a window of 22 days which you can ask a question\n */\n\n// This is the Stater's bank If he's with the truth\n// The amount of money will keep growing until maturity\n// Scheduler at 30 days kills the contract | to save space on network\n// and gas refund\ncontract StatementBank {\n    using SafeMath for uint256;\n\n    address payable public stater; // owner\n\n    uint256 public firstQuestioner;\n    uint256 public lastQuestioner;\n    uint256 public createdAt;\n    uint256 public questionDeadline;\n    uint256 public statementTimeLock;\n\n    // returns the amount the statementBank has at all times\n    function statementBankBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    // potential util for generating a random number to get\n    // voter who gets reward\n    // set to public for testing [TODO: must set to private]\n    // arg: _numberOfVoters number of voters\n    // result: starts at zero | \n    function random(uint256 _numberOfVoters) public view returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty))).mod(_numberOfVoters);\n    }\n\n    // (1): stater posts a statement\n    function initialize() public payable {\n        require(msg.value == 0.04 ether);\n        stater = msg.sender;\n        // natural unit of time on EVM is seconds\n        createdAt = now;\n        // 18 days to ask a questions\n        questionDeadline = now.add(5 minutes);\n        statementTimeLock = now.add(10 minutes);\n    }\n\n    // We're using a FIFO data structure, that represents the order of\n    // questions, first ones get settled first\n    // firstQuestioner and lastQuestioner serve as the index for both:\n    // questioners order and votes on each on those question\n    // 1st arg: _questionIndex\n    // result: questioner's address\n    mapping (uint256 => address payable) public questioners;\n\n\n    // (2): questioner asks a question\n    // only question staker should be able to run this function\n    // [No restriction] on when a question stake can be issued\n    // [todo: Maybe deactivate when contract less than $2]\n    // The more money in the contract (and less true), the more likely a questionerStake\n    function questionerStake() payable public {\n        // should be called before deadline\n        require(questionDeadline > now);\n        require(msg.value == 0.004 ether);\n        require(stater != msg.sender);\n        lastQuestioner = lastQuestioner.add(1);\n        questioners[lastQuestioner] = msg.sender;\n    }\n    \n    // question got an answer from stater\n    // This is to safeguard the must follow cretter: statement -> question -> answer -> votes\n    // 1st arg: _questionIndex\n    // 2nd arg: whether the question got answer (existence is yes/1)\n    mapping (uint256 => uint256) public questionGotAnswer;\n    \n    // (3): stater answers to question\n    // The only way for the stater to signal that he/she actually answered\n    // the question is by making a transaction\n    function staterProvidesAnswer(uint256 _questionIndex) public {\n        require (msg.sender == stater);\n\n        // stater can't signal he already answered a question\n        // when a question hasn't been asked yet | mainly checking for existence\n        require(lastQuestioner > _questionIndex);\n        \n        // booleans take more space than uint256\n        questionGotAnswer[_questionIndex] = 1;\n        \n        // TODO: disable stater being able to call this function again.\n        // Stater can't update or edit, an already supplied answer\n        // 99 coz bearish on answers by default (100 or above, stater is winning)\n        staterAgainstQuestionIndex[_questionIndex] = 99;\n    }\n\n    // 1st arg: _questionIndex\n    // 2nd arg: _truthIndex\n    // the truth index threshold is 100 (100 or above stater wins - starts at 99)\n    // lower: stater is losing argument over the question at _questionIndex\n    // higher: stater is winning argument ...\n    mapping (uint256 => uint256) public staterAgainstQuestionIndex;\n\n    // 1st arg: _questionIndex\n    // 2nd arg: voterAddress\n    // 3rd: 1 > signifies [voted] // existence means yes/1\n    mapping (uint256 => mapping (address => uint256)) public hasAlreadyVoted;\n    \n    // mapping to mainly reward the lucky voter who got it right\n    mapping (uint256 => address payable[]) votedForStater;\n    mapping (uint256 => address payable[]) votedForQuestioner;\n    \n    // (4): voting\n    // Vote answer on question, binary:\n    // * satisfying: stater wins / Vote\n    // * unsatisfying: questioner wins / Vote\n    // 1st arg: _questionIndex \n    // 2nd arg: vote: 1 stater favor (agree answer), 2 questioner favor (disagree answer)\n    function vote(uint256 _questionIndex, uint256 _vote) public {\n        \n        require(questionGotAnswer[_questionIndex] == 1);\n        \n        // stater or questioner can't vote\n        require(msg.sender != stater);\n        // This has a 0.2% gas limit addition so add it (not big)\n        require(msg.sender != questioners[_questionIndex]);\n        \n        // if already voted _questionIndex, can't vote again\n        require(hasAlreadyVoted[_questionIndex][msg.sender] != 1);\n        \n        // 1 stater favor (agree answer)\n        if (_vote == 1) {\n            staterAgainstQuestionIndex[_questionIndex] = staterAgainstQuestionIndex[_questionIndex].add(1);\n            votedForStater[_questionIndex].push(msg.sender);\n            \n        // 2 questioner favor (disagree answer)\n        } else if (_vote == 2) {\n            staterAgainstQuestionIndex[_questionIndex] = staterAgainstQuestionIndex[_questionIndex].sub(1);\n            votedForQuestioner[_questionIndex].push(msg.sender);\n        }\n        \n        // record voter\n        hasAlreadyVoted[_questionIndex][msg.sender] = 1;\n    }\n    \n    \n    // [Only] Scheduler can call this\n    // Function [dequeue] the oldest question \n    // * To save on transfer fees and give an addictive spin:\n    // * choose a random ranker who got it right and pay him $0.5\n    // [originally 10% of the questioner's stake was the spec]\n    function finalizeQuestionerChallenge () public returns (address removedQuestionerAddr) {\n        require(lastQuestioner >= firstQuestioner);\n        \n        // Test still\n        // require(msg.sender == address(0xa639cc7A169E848B280acd1B493a7D5Af44507a4)); \n\n        // If stater didn't answer, questioner wins automatically\n        // 0 is the default (represent not having an answer)\n\n        // If SAQI is 99, voters didn't move the needle, they don't get paid\n        if (questionGotAnswer[firstQuestioner] == 0 || staterAgainstQuestionIndex[firstQuestioner] == 99) {\n            questioners[firstQuestioner].transfer(0.008 ether);\n        } else if (staterAgainstQuestionIndex[firstQuestioner] < 100) {\n            // questioner wins, he gets 2x his staked money\n            questioners[firstQuestioner].transfer(0.008 ether);\n\n            // reward a random ranker who betted on questioner\n\n            uint256 questLen = votedForQuestioner[firstQuestioner].length;\n\n            uint256 questVoteIndex = random(questLen);\n\n            // Important votedForStater && votedForQuestioner started with index 0\n            // Must decrease by 1 for proper indexing\n            address payable questionerRankingWinner = votedForQuestioner[firstQuestioner][questVoteIndex];\n            \n            // Variable reward: the earlier you voted the more you deserve a full reward\n            \n            // uint256 questVoterReward = 2000000000000000 * (1 - (questVoteIndex / questLen)); // in wei\n            uint256 questVoterReward = uint256(2000000000000000).sub( uint256(2000000000000000).mul(questVoteIndex).div(questLen) );\n            \n            questionerRankingWinner.transfer(questVoterReward);\n            \n        } else if (staterAgainstQuestionIndex[firstQuestioner] >= 100) {\n            // stater is winning (a tie, he's still winning) coz\n            // the goal of questioner is to kill the statement\n            // > nothing to do here money stays in the contract\n            // > reward a random ranker who betted on stater\n            \n            uint256 stateLen = votedForStater[firstQuestioner].length;\n            uint256 staterVoteIndex = random(stateLen);\n            address payable staterRankingWinner = votedForStater[firstQuestioner][staterVoteIndex];\n\n            \n            uint256 stateVoterReward = uint256(2000000000000000).sub(uint256(2000000000000000).mul(staterVoteIndex).div(stateLen));\n            staterRankingWinner.transfer(stateVoterReward);\n        }\n        \n        removedQuestionerAddr = questioners[firstQuestioner];\n        delete questioners[firstQuestioner];\n\n        firstQuestioner = firstQuestioner.add(1);\n    }\n    \n    // Until a stater can retrieve money from the statementBankBalance\n    // [This to be implemented later]\n    \n    // Only Scheduler can call this\n    function staterReceivesLoot() public {\n        // require(msg.sender == address(0xa639cc7A169E848B280acd1B493a7D5Af44507a4));\n        // should be called after deadline\n\n        require(now > statementTimeLock);\n\n        \n        // We need a bunch of checks here \n        // All rounds of questions challenges must be done\n        // All question challenges finalized\n        require(lastQuestioner == firstQuestioner);\n        \n        // TODO: implement time waiting requirement\n        // The only strict restriction is that enough time like 2 weeks should go on\n        \n        // Fund future development of cretter\n        uint256 fundCretterFuture = 4000000000000000; // 0.004 ether \n        address payable cretterFundAddr = 0x87aD567CE024832E60529e11e70cb3788611F1E8;\n        \n        cretterFundAddr.transfer(fundCretterFuture);\n        stater.transfer(statementBankBalance().sub(fundCretterFuture));      \n    }\n    \n    // Funders can donate and keep statement live\n    // for more interaction even after stater withdrawal\n    // Reward always goes to stater though (if not drained by questioners)\n    // function donateToStatementBank() public payable {}\n}\n\n\n// see comments at https://github.com/0age/Spawner\ncontract Spawn {\n  constructor(\n    address logicContract,\n    bytes memory initializationCalldata\n  ) public payable {\n    // delegatecall into the logic contract to perform initialization.\n    (bool ok, ) = logicContract.delegatecall(initializationCalldata);\n    if (!ok) {\n      // pass along failure message from delegatecall and revert.\n      assembly {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n    }\n\n    // place eip-1167 runtime code in memory.\n    bytes memory runtimeCode = abi.encodePacked(\n      bytes10(0x363d3d373d3d3d363d73),\n      logicContract,\n      bytes15(0x5af43d82803e903d91602b57fd5bf3)\n    );\n\n    // return eip-1167 code to write it to spawned contract runtime.\n    assembly {\n      return(add(0x20, runtimeCode), 45) // eip-1167 runtime code, length\n    }\n  }\n}\n\ncontract SpawnCompact {\n  constructor(\n    address logicContract,\n    bytes memory initializationCalldata\n  ) public payable {\n    // delegatecall into the logic contract to perform initialization.\n    (bool ok, ) = logicContract.delegatecall(initializationCalldata);\n    if (!ok) {\n      // pass along failure message from delegatecall and revert.\n      assembly {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n    }\n\n    // place eip-1167 runtime code in memory.\n    bytes memory runtimeCode = abi.encodePacked(\n      bytes10(0x363d3d373d3d3d363d6e),\n      uint120(uint160(logicContract)),\n      bytes15(0x5af43d82803e903d91602b57fd5bf3)\n    );\n\n    // return eip-1167 code to write it to spawned contract runtime.\n    assembly {\n      return(add(0x20, runtimeCode), 40) // eip-1167 runtime code, length\n    }\n  }\n}\n\ncontract Spawner {\n  function _spawn(\n    address logicContract,\n    bytes memory initializationCalldata\n  ) internal returns (address spawnedContract) {\n    // place creation code and constructor args of contract to spawn in memory.\n    bytes memory initCode = abi.encodePacked(\n      type(Spawn).creationCode,\n      abi.encode(logicContract, initializationCalldata)\n    );\n\n    // spawn the contract using `CREATE2`.\n    spawnedContract = _spawnCreate2(initCode);\n  }\n\n  function _spawnCompact(\n    address compactLogicContract,\n    bytes memory initializationCalldata\n  ) internal returns (address spawnedContract) {\n    // ensure that the address is sufficiently compact.\n    _ensureCompact(compactLogicContract);\n\n    // place creation code and constructor args of contract to spawn in memory.\n    bytes memory initCode = abi.encodePacked(\n      type(SpawnCompact).creationCode,\n      abi.encode(compactLogicContract, initializationCalldata)\n    );\n\n    // spawn the contract using `CREATE2`.\n    spawnedContract = _spawnCreate2(initCode);\n  }\n\n  function _spawnOldSchool(\n    address logicContract,\n    bytes memory initializationCalldata\n  ) internal returns (address spawnedContract) {\n    // place creation code and constructor args of contract to spawn in memory.\n    bytes memory initCode = abi.encodePacked(\n      type(Spawn).creationCode,\n      abi.encode(logicContract, initializationCalldata)\n    );\n\n    // spawn the contract using `CREATE`.\n    spawnedContract = _spawnCreate(initCode);\n  }\n\n  function _spawnCompactOldSchool(\n    address compactLogicContract,\n    bytes memory initializationCalldata\n  ) internal returns (address spawnedContract) {\n    // ensure that the address is sufficiently compact.\n    _ensureCompact(compactLogicContract);\n\n    // place creation code and constructor args of contract to spawn in memory.\n    bytes memory initCode = abi.encodePacked(\n      type(SpawnCompact).creationCode,\n      abi.encode(compactLogicContract, initializationCalldata)\n    );\n\n    // spawn the contract using `CREATE`.\n    spawnedContract = _spawnCreate(initCode);\n  }\n\n  \n  function _computeNextAddress(\n    address logicContract,\n    bytes memory initializationCalldata\n  ) internal view returns (address target) {\n    // place creation code and constructor args of contract to spawn in memory.\n    bytes memory initCode = abi.encodePacked(\n      type(Spawn).creationCode,\n      abi.encode(logicContract, initializationCalldata)\n    );\n\n    // get target address using the constructed initialization code.\n    (, target) = _getSaltAndTarget(initCode);\n  }\n\n  function _computeNextCompactAddress(\n    address compactLogicContract,\n    bytes memory initializationCalldata\n  ) internal view returns (address target) {\n    // ensure that the address is sufficiently compact.\n    _ensureCompact(compactLogicContract);\n\n    // place creation code and constructor args of contract to spawn in memory.\n    bytes memory initCode = abi.encodePacked(\n      type(SpawnCompact).creationCode,\n      abi.encode(compactLogicContract, initializationCalldata)\n    );\n\n    // get target address using the constructed initialization code.\n    (, target) = _getSaltAndTarget(initCode);\n  }\n\n  function _spawnCreate(\n    bytes memory initCode\n  ) private returns (address spawnedContract) {\n    assembly {\n      let encoded_data := add(0x20, initCode) // load initialization code.\n      let encoded_size := mload(initCode)     // load the init code's length.\n      spawnedContract := create(              // call `CREATE` with 3 arguments.\n        callvalue(),                            // forward any supplied endowment.\n        encoded_data,                         // pass in initialization code.\n        encoded_size                          // pass in init code's length.\n      )\n\n      // pass along failure message from failed contract deployment and revert.\n      if iszero(spawnedContract) {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n    }\n  }\n\n  function _spawnCreate2(\n    bytes memory initCode\n  ) private returns (address spawnedContract) {\n    // get salt to use during deployment using the supplied initialization code.\n    (bytes32 salt, ) = _getSaltAndTarget(initCode);\n\n    assembly {\n      let encoded_data := add(0x20, initCode) // load initialization code.\n      let encoded_size := mload(initCode)     // load the init code's length.\n      spawnedContract := create2(             // call `CREATE2` w/ 4 arguments.\n        callvalue(),                            // forward any supplied endowment.\n        encoded_data,                         // pass in initialization code.\n        encoded_size,                         // pass in init code's length.\n        salt                                  // pass in the salt value.\n      )\n\n      // pass along failure message from failed contract deployment and revert.\n      if iszero(spawnedContract) {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n    }\n  }\n\n  function _getSaltAndTarget(\n    bytes memory initCode\n  ) private view returns (bytes32 salt, address target) {\n    // get the keccak256 hash of the init code for address derivation.\n    bytes32 initCodeHash = keccak256(initCode);\n\n    // set the initial nonce to be provided when constructing the salt.\n    uint256 nonce = 0;\n    \n    // declare variable for code size of derived address.\n    uint256 codeSize;\n\n    while (true) {\n      // derive `CREATE2` salt using `msg.sender` and nonce.\n      salt = keccak256(abi.encodePacked(msg.sender, nonce));\n\n      target = address(    // derive the target deployment address.\n        uint160(                   // downcast to match the address type.\n          uint256(                 // cast to uint to truncate upper digits.\n            keccak256(             // compute CREATE2 hash using 4 inputs.\n              abi.encodePacked(    // pack all inputs to the hash together.\n                bytes1(0xff),      // pass in the control character.\n                address(this),     // pass in the address of this contract.\n                salt,              // pass in the salt from above.\n                initCodeHash       // pass in hash of contract creation code.\n              )\n            )\n          )\n        )\n      );\n\n      // determine if a contract is already deployed to the target address.\n      assembly { codeSize := extcodesize(target) }\n\n      // exit the loop if no contract is deployed to the target address.\n      if (codeSize == 0) {\n        break;\n      }\n\n      // otherwise, increment the nonce and derive a new salt.\n      nonce++;\n    }   \n  }   \n\n  function _ensureCompact(address logicContract) private pure {\n    // ensure that the address is sufficiently compact.\n    require(\n      uint160(logicContract) <= 0xffffffffffffffffffffffffffffff,\n      \"Logic contract address must start with at least five zero bytes.\"\n    );    \n  }  \n}\n\ncontract StatementFactory is Spawner {\n  function postNewStatement(address _statementBankLogicAdrr) public returns (address spawnedContract) {\n\n    StatementBank statementLogic = StatementBank(_statementBankLogicAdrr);\n    \n    bytes memory myInitializationCalldata = abi.encodeWithSelector(\n      statementLogic.initialize.selector\n      // ,\n      // \"argumentOne\",\n      // \"argumentTwo\"\n    );\n    \n    spawnedContract =  _spawn(\n      address(statementLogic),\n      myInitializationCalldata\n    );\n  }\n}"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}